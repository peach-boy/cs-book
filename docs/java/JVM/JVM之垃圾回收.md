# JVM 之垃圾回收

## 一、对象的生与死

#### 1、引用计数算法

给对象添加一个引用计数器，每当有一个地方引用它时，计数器加 1，引用失效减 1。主要问题很难解决循环引用的问题。

#### 2、跟搜索算法

通过一些 GCRoots 对象来作为节点，搜索所有走过的路径称为引用链，当一个对象到 GCRoots 没有任何引用链（在图论中即为从 GCRoots 到这个对象不可达），则对象时不可用的。可作为 GCRoots 的对象：

- 虚拟机栈中的栈帧中的本地变量表中的引用对象
- 方法区中的静态属性引用的对象
- 方法区中的常量引用对象
- 本地方法栈中的 native 方法的引用的对象

## 二、对象访问

#### 1、直接引用(强应用)

```java
Object obj=new Object();
```

- object obj 在栈的本地变量中是作为一个 reference 类型数据出现。reference 类型在虚拟机中的主流做法，是使用句柄和直接指针。
- new Object()在堆上开辟一块内存，存储 object 类型所有的实例数据值。
- 只要强引用还存在，垃圾回收永远不会回收被引用的对象内存

### 2、软引用（soft reference）

- 描述的一些还有用，但是非必须的对象。在系统将要发生内存溢出 异常之前，将会把这些对象列为回收范围之中并进行第二次回收。

### 3、弱引用（weak reference）

- 也是来描述非必须的对象，但是它的强度比软引用更弱一些，当垃圾回收器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象
- java 中的 ThreadLocal 和 WeakhashMap 得到了应用

### 4、 虚引用（phantom reference）

- 最弱的一种引用关系，不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制

## 三、垃圾回收算法

### 1、标记-清除算法

标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。

- 缺点：但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。

### 2、复制算法

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。

- 对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。很显然，Copying 算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么 Copying 算法的效率将会大大降低。

### 3、标记-整理算法

该算法标记阶段和标记清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。

### 4、分代收集算法

分代收集算法是目前大部分 JVM 的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young）

- 新生代：目前大部分垃圾收集器都采取复制算法。
  > 因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照 1：1 的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将 Eden 和 Survivor 中还存活的对象复制到另一块 Survivor 空间中，然后清理掉 Eden 和刚才使用过的 Survivor 空间。
- 老年代：特点是每次回收都只回收少量对象，一般使用的是标记-整理算法

## 四、垃圾回收器

## 五、内存分配与回收策略
