# 并发应用篇

## 1.ThreadPoolExecutor原理简析

#### ThreadPoolExecutor的重要参数
1. corePoolSize：核心线程数
    - 核心线程会一直存活，及时没有任务需要执行
    - 线程数 < corePoolSize时，即使有线程空闲，线程池也会优先创建新线程处理
    - 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭
2. queueCapacity：任务队列容量（阻塞队列）
    当核心线程数达到最大时，新任务会放在队列中排队等待执行
3. maxPoolSize：最大线程数
    - 线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
    - 线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常
4. keepAliveTime：线程空闲时间
    - 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
    - 如果allowCoreThreadTimeout=true，则会直到线程数量=0
5. allowCoreThreadTimeout：允许核心线程超时
6. rejectedExecutionHandler：任务拒绝处理器,两种情况会拒绝处理任务：
    - 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
    - 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务
    - 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常
7. 拒绝策略：
    - AbortPolicy 直接抛出一个RejectedExecutionException，这也是JDK默认的拒绝策略
    - CallerRunsPolicy 尝试直接运行被拒绝的任务，如果线程池已经被关闭了，任务就被丢弃了
    - DiscardPolicy 不能执行的任务将被删除
    - DiscardOldestPolicy 移除最晚的那个没有被处理的任务，然后执行被拒绝的任务。同样，如果线程池已经被关闭了，任务就被丢弃了
    - 自定义：实现RejectedExecutionHandler接口，可自定义处理器
``` 
/**
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

#### ThreadPoolExecutor执行顺序
1. currentThreadNum < corePoolSize->创建线程。
2. corePoolSize =< currentThreadNum ，对列未满，加入队列。
3. corePoolSize =< currentThreadNum <maxPoolSize ，且任务队列已满,创建线程
4. corePoolSize =< currentThreadNum &&currentThreadNum>=maxPoolSize ,且任务队列已满,创建线程，抛出异常，拒绝任务
 
 
 
#### 如何设置参数
- 默认值
    - corePoolSize=1
    - queueCapacity=Integer.MAX_VALUE
    - maxPoolSize=Integer.MAX_VALUE
    - keepAliveTime=60s
    - allowCoreThreadTimeout=false
    - rejectedExecutionHandler=AbortPolicy()
- 如何来设置
    1. 需要根据几个值来决定
        - tasks ：每秒的任务数，假设为500~1000
        - taskcost：每个任务花费时间，假设为0.1s
        - responsetime：系统允许容忍的最大响应时间，假设为1s
    2. 做几个计算
        - corePoolSize = 每秒需要多少个线程处理？ 
threadcount = tasks/(1/taskcost) =tasks*taskcout =  (500~1000)*0.1 = 50~100 个线程。corePoolSize设置应该大于50
根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可
        - queueCapacity = (coreSizePool/taskcost)*responsetime
计算可得 queueCapacity = 80/0.1*1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行
切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。
        - maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)
计算可得 maxPoolSize = (1000-80)/10 = 92
（最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数
        - rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理
        - keepAliveTime和allowCoreThreadTimeout采用默认通常能满足


## 2.FutureTask,Future和Callable

#### 如何获取线程的执行结果
Java 通过 ThreadPoolExecutor 提供的 3 个 submit() 方法，两个invoke方法和 1 个 FutureTask 工具类来支持获得任务执行结果的需求
```
    // 提交Runnable任务
    Future<?> submit(Runnable task);
    // 提交Callable任务
    <T> Future<T> submit(Callable<T> task);
    // 提交Runnable任务及结果引用  
    <T> Future<T> submit(Runnable task, T result);
     // 批量提交任务
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)throws InterruptedException;
    // 批量提交任务（支持超时机制）
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit)throws  InterruptedException;
```

#### 1.Future接口：
```
    //取消任务的方法
    boolean cancel(boolean mayInterruptIfRunning);
    //判断任务是否已取消的方法
    boolean isCancelled();
    //判断任务是否已结束的方法
    boolean isDone();
    //获得任务执行结果
    V get() throws InterruptedException, ExecutionException;
    //获得任务执行结果(支持超时机制`)
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
```
1. get方法：`V get() throws InterruptedException, ExecutionException;`
    - 当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；
    -  当FutureTask处于已完成状态，调用FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。
 2. cancel方法: `boolean cancel(boolean mayInterruptIfRunning);`
    - 当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；
    - 当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；
    - 当FutureTask处于已启动状态时，执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；
    - 当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。
3. get和cancel执行示例图
![FutureTask的get和cancel的执行示意图](/pic/java/FutureTask_1.png)

4. Callable+Future使用示例
 ```
 public class FutureTaskTest {
    static class CallableTask implements Callable<String> {
        private Integer sleepTime;

        public CallableTask(Integer sleepTime) {
            this.sleepTime = sleepTime;
        }

        @Override
        public String call() throws Exception {
            System.out.println(Thread.currentThread().getName()+"--begin--"+System.currentTimeMillis());
            Thread.sleep(sleepTime);
            System.out.println(Thread.currentThread().getName()+"-------end--"+System.currentTimeMillis());
            return Thread.currentThread().getName();
        }
    }

    public static void main(String[] args) {

        ExecutorService executorService = Executors.newFixedThreadPool(3);

        List<Callable<String>> callableList = new ArrayList<>();
        callableList.add(new CallableTask(2000));
        callableList.add(new CallableTask(5000));
        callableList.add(new CallableTask(2000));

        try {
            List<Future<String>> futures = executorService.invokeAll(callableList);
            System.out.println("return future--"+System.currentTimeMillis());
            for (Future future : futures) {
                System.out.println(future.get() + "--get---"+System.currentTimeMillis());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println("main thread compelete");
        executorService.shutdown();
    }
}
console result:
pool-1-thread-1--begin--1561992318002
pool-1-thread-3--begin--1561992318002
pool-1-thread-2--begin--1561992318002
pool-1-thread-3-------end--1561992320003
pool-1-thread-1-------end--1561992320003
pool-1-thread-2-------end--1561992323003
return future--1561992323003
pool-1-thread-1--get---1561992323003
pool-1-thread-2--get---1561992323004
pool-1-thread-3--get---1561992323004
 ```


#### 2.FutureTask工具类
FutureTask 是一个实实在在的工具类，这个工具类有两个构造函数，它们的参数和前面介绍的 submit() 方法类似。
```
FutureTask(Callable<V> callable);
FutureTask(Runnable runnable, V result);
```
FutureTask 实现了 Runnable 和 Future 接口，由于实现了 Runnable 接口，所以可以将 FutureTask 对象作为任务提交给 ThreadPoolExecutor 去执行，也可以直接被 Thread 执行；又因为实现了 Future 接口，所以也能用来获得任务的执行结果

 Callable+FutureTask使用示例
 ```
public static class CallableThread implements Callable<String>
{
    public String call() throws Exception
    {
        System.out.println("进入CallableThread的call()方法, 开始睡觉, 睡觉时间为" + System.currentTimeMillis());
        Thread.sleep(10000);
        return "123";
    }
}
    
public static void main(String[] args) throws Exception
{
    ExecutorService es = Executors.newCachedThreadPool();
    CallableThread ct = new CallableThread();
    FutureTask<String> f = new FutureTask<String>(ct);
    es.submit(f);
    es.shutdown();
        
    Thread.sleep(5000);
    System.out.println("主线程等待5秒, 当前时间为" + System.currentTimeMillis());
        
    String str = f.get();
    System.out.println("Future已拿到数据, str = " + str + ", 当前时间为" + System.currentTimeMillis());
}
 ```
 
#### 3.InterruptedException如何处理
- 何时会发生：当阻塞方法收到中断请求的时候就会抛出InterruptedException异常
- 不要不管不顾:捕获到InterruptedException异常后恢复中断状态
```
public class TaskRunner implements Runnable {
    private BlockingQueue<Task> queue;
 
    public TaskRunner(BlockingQueue<Task> queue) { 
        this.queue = queue; 
    }
 
    public void run() { 
        try {
             while (true) {
                 Task task = queue.take(10, TimeUnit.SECONDS);
                 task.execute();
             }
         }
         catch (InterruptedException e) { 
             // Restore the interrupted status
             Thread.currentThread().interrupt();
         }
    }
}
```


## 3.并发工具类

#### 1、CountDownLatch（倒计时）
 
- CountDownLatch的作用：允许一个或多个线程，等待其他线程达到触发条件时（触发条件即CountDownLatch对象计数器减为0时）才开始执行
- 主要方法
    1. CountDownLatch构造函数：CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完
成，这里就传入N
    2. countDown：当我们调用CountDownLatch的countDown方法时，N就会减1
    3. await:CountDownLatch的await方法
会阻塞当前线程，直到N变成零,当前线程才会执行；await（long time，TimeUnit unit）这个方法等待特定时
间后，就会不再阻塞当前线程
- 示例代码：
```**
 * @Description: TODO
 * @Auther: ThomasWu
 * @Date: 2019/6/22 20:53
 * @Email:1414924381@qq.com
 */
public class CountDownLatchTest {
    private static class WorkTask extends Thread {
        private CountDownLatch countDownLatch;

        public WorkTask(String name, CountDownLatch countDownLatch) {
            super(name);
            this.countDownLatch = countDownLatch;
        }

        @Override
        public void run() {
            try {
                System.out.println(this.getName() + "启动了"+System.currentTimeMillis());
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println(this.getName() + "执行完了"+System.currentTimeMillis());
                countDownLatch.countDown();
            }
        }
    }

    private static class DoneTask extends Thread {
        private CountDownLatch countDownLatch;

        public DoneTask(String name, CountDownLatch countDownLatch) {
            super(name);
            this.countDownLatch = countDownLatch;
        }

        @Override
        public void run() {
            try {
                System.out.println(this.getName() + "开始等待"+System.currentTimeMillis());
                countDownLatch.await();
                System.out.println(this.getName() + "执行完了"+System.currentTimeMillis());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public static void main(String[] args) {
        CountDownLatch countDownLatch=new CountDownLatch(3);
        ExecutorService service=Executors.newFixedThreadPool(5);
        service.submit(new DoneTask("DonwTask1",countDownLatch));
        service.submit(new DoneTask("DoneTask2",countDownLatch));
        service.submit(new WorkTask("workTask1",countDownLatch));
        service.submit(new WorkTask("workTask2",countDownLatch));
        service.submit(new WorkTask("workTask3",countDownLatch));
    }
}
console result
DonwTask1开始等待1561210606078
DoneTask2开始等待1561210606078
workTask2启动了1561210606079
workTask1启动了1561210606079
workTask3启动了1561210606079
workTask3执行完了1561210607079
workTask2执行完了1561210607079
workTask1执行完了1561210607079
DonwTask1执行完了1561210607079
DoneTask2执行完了1561210607079
```


#### 2、CyclicBarrier(同步屏障或栅栏)

- CyclicBarrier作用:让一
组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会
开门，所有被屏障拦截的线程才会继续运行
- 主要方法
    1. 构造函数CyclicBarrier（int parties，Runnable barrierAction）:用于在线程到达屏障时，优先执行barrierAction
    2. 默认构造函数CyclicBarrier（int parties）：屏障拦截的线程数
量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞
    3. await:调用该方法的线程会被阻塞
- 注意：线程池中使用CyclicBarrier ，要考虑线程被阻塞问题，

- 示例代码
```/**
 * @Description: 多任务结算银行流水
 * @Auther: ThomasWu
 * @Date: 2019/6/22 22:32
 * @Email:1414924381@qq.com
 */
public class CyclicBarrierTest {
    static class BankWaterTask implements Runnable {
        private ConcurrentHashMap<String, Integer> sheetBankWaterCount = new ConcurrentHashMap<String, Integer>();
        private CyclicBarrier c = new CyclicBarrier(4, this);
        private Executor executor = Executors.newFixedThreadPool(4);

        private void count() {
            System.out.println("count 开始" + System.currentTimeMillis());
            for (int i = 0; i < 4; i++) {
                executor.execute(() -> {
                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);
                    try {
                        c.await();
                    } catch (InterruptedException | BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                });
            }
            System.out.println("count 结束" + System.currentTimeMillis());
        }

        @Override
        public void run() {
            System.out.println("run" + System.currentTimeMillis());
            int result = 0;
            for (Map.Entry<String, Integer> sheet : sheetBankWaterCount.entrySet()) {
                result += sheet.getValue();
            }
            sheetBankWaterCount.put("result", result);
            System.out.println(result);
        }

    }

   public static void main(String[] args) {
        BankWaterTask task = new BankWaterTask();
        task.count();
    }
```

#### 3、Semaphore(信号量) 

- Semaphore的作用：用来控制同时访问特定资源的线程数量，它通过协调各个线程，以
保证合理的使用公共资源
- 使用场景： Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假
如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程
并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这
时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连
接。这个时候，就可以使用Semaphore来做流量控制
- 主要方法：可以简单概括为：一个计数器，一个等待队列（AQS阻塞队列），三个方法
    1. Semaphore（int permits）：接受一个整型的数字，表示可用的许可证数量
    2. void acquire()：获取一个许可证，如果当前信号量大于0，则当前信号量的计数减1，该方法直接返回；如果当前信号量等于0，则当前线程会被放入AQS阻塞队列
    3. void release():将当前信号量加1

示例代码：
```

/**
 * @Description: TODO
 * @Auther: ThomasWu
 * @Date: 2019/6/23 15:19
 * @Email:1414924381@qq.com
 */
public class SemaphoreTest {
    private static final int THREAD_COUNT = 10;
    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);
    private static Semaphore s = new Semaphore(5);

    public static void main(String[] args) {
        for (int i = 0; i < THREAD_COUNT; i++) {
            threadPool.execute(() -> {
                try {
                    s.acquire();
                    System.out.println(Thread.currentThread().getName()+"获得了信号量"+"---当前信号量:"+s.availablePermits()+"---等待信号量的线程数:"+s.getQueueLength()+"---"+System.currentTimeMillis());
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    s.release();
                    System.out.println(Thread.currentThread().getName()+"释放了信号量------"+"---当前信号量:"+s.availablePermits()+"---等待信号量的线程数:"+s.getQueueLength()+System.currentTimeMillis());
                }
            });
        }
        threadPool.shutdown();
    }
}

console result
pool-1-thread-2获得了信号量---当前信号量:4---等待信号量的线程数:0---1561275554694
pool-1-thread-1获得了信号量---当前信号量:3---等待信号量的线程数:0---1561275554694
pool-1-thread-4获得了信号量---当前信号量:2---等待信号量的线程数:0---1561275554694
pool-1-thread-3获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275554694
pool-1-thread-5获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275554694
pool-1-thread-6获得了信号量---当前信号量:0---等待信号量的线程数:4---1561275556695
pool-1-thread-7获得了信号量---当前信号量:0---等待信号量的线程数:3---1561275556695
pool-1-thread-4释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695
pool-1-thread-1释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695
pool-1-thread-8获得了信号量---当前信号量:0---等待信号量的线程数:2---1561275556695
pool-1-thread-2释放了信号量---------当前信号量:0---等待信号量的线程数:21561275556695
pool-1-thread-9获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275556696
pool-1-thread-3释放了信号量---------当前信号量:0---等待信号量的线程数:01561275556696
pool-1-thread-5释放了信号量---------当前信号量:1---等待信号量的线程数:01561275556696
pool-1-thread-10获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275556696
pool-1-thread-6释放了信号量---------当前信号量:1---等待信号量的线程数:01561275558695
pool-1-thread-8释放了信号量---------当前信号量:3---等待信号量的线程数:01561275558695
pool-1-thread-7释放了信号量---------当前信号量:2---等待信号量的线程数:01561275558695
pool-1-thread-10释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696
pool-1-thread-9释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696
```


#### 4、Exchanger

 - Exchanger作用：用于进行线程间的数据交
换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过
exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也
执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产
出来的数据传递给对方。
- 注意：如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发
生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长



 示例代码：
 ```
/**
 * @Description: TODO
 * @Auther: ThomasWu
 * @Date: 2019/6/23 15:53
 * @Email:1414924381@qq.com
 */
public class ExchangerTest {

    private static final Exchanger<String> exchanger = new Exchanger<String>();
    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);

    public static void main(String[] args) {
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    // A录入银行流水数据
                    String str = "银行流水A";
                    System.out.println(Thread.currentThread().getName() + str);
                    str = exchanger.exchange(str);
                    System.out.println(Thread.currentThread().getName() + str);
                } catch (InterruptedException e) {
                }
            }
        });
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    String str = "银行流水B";
                    System.out.println(Thread.currentThread().getName() + str);
                    str = exchanger.exchange(str);
                    System.out.println(Thread.currentThread().getName() + str);

                } catch (InterruptedException e) {
                }
            }
        });
        threadPool.shutdown();
    }
}

 ```

#### 5. CyclicBarrier和CountDownLatch的区别
1. CountDownLatch主要用来解决一个线程等待多个线程的场景,例如：旅游团团长要等待所有的游客到齐才能去下一个景点
2. CyclicBarrier 是一组线程之间互相等待，例如：就像几个驴友之间不离不弃
3. CountDownLatch 的计数器是不能循环利用的，也就是说一旦计数器减到 0，再有线程调用 await()，该线程会直接通过。
4.  CyclicBarrier 的计数器是可以循环利用的，而且具备自动重置的功能，一旦计数器减到 0 会自动重置到你设置的初始值。除此之外，CyclicBarrier 还可以设置回调函数
 
