# 基础篇

## 一、主要概念及重要参数

- producer：生产者，投递消息的一方
- consumer：消费者，接收消息的一方
  - prefetch ：预取默认值
- broker:消息中间件的服务节点
- queue:队列
  - rabbitmq 的内部对象，用于存储消息。rabbitmq 中的消息只能存储在队列中。
  - 多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin,及轮询）给多个消费者，而不是每个消费者都收到所有的消息。
  - rabbitmq 不支持队列层面上的广播消费。
- exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或多个队列中。
  - direct:此类型交换器会将消息投递到，routingKey 和 bindingKey 完全相同的队列中。
  - fanout:它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。
  - topic:routingKey 和 bindingKey 会按照一定的规则匹配,消息会被发送到匹配中的队列上去。规则如下
    bindingKey 中可以存在两种特殊字符*和#,*用于匹配一个单词，#用于匹配多个单词。
    ![](../../../pic/中间件/rabbitmq_2.png)
  - headers:不根据路由键匹配规则来路由消息，而是根据发送消息内容中的 headers 属性进行匹配。此类型交换器性能较差，使用较少。
- routingKey:路由键，生产者将消息发送给交换器，一般会指定一个 routingKey,用于指定消息的路由规则。
- bindingKey:用于将交换器和队列绑定。
- connection:消费者和生产者需要与 broker 建立 TCP 连接，也就是 connection
- channel:AMQP 信道，每个信道都会被指派一个唯一的 ID,信道是建立在 connection 之上的虚拟连接，每一条 AMQP 指令都是通过信道完成的。TCP 连接的建立和销毁是非常昂贵的开销，信道相当于轻量级连接，
- vhost:
  - virtual host 只是起到一个命名空间的作用，所以可以多个 user 共同使用一个 virtual host，文章开头写的 vritual_host = '/'，这个是系统默认的。
  - vhost 是 rabbitmq 分配权限的最小细粒度,比如我们可以为一个用户分配一个可以访问哪个或者哪一些 vhost 的权限,但是不能为用户分配一个可以访问哪一些 exchange，或者 queue 的权限，因为 rabbitmq 的权限细粒度没有细化到交换器和队列，他的最小细粒度是 vhost(vhost 中包含许多的 exchanges，queues，bingdings).所以如果 exchangeA 和 queueA 只能让用户 A 访问，exchangeB 和 queueB 只能让用户 B 访问，要达到这种需求，只能为 exchangeA 和 queueA 创建一个 vhostA，为 exchangeB 和 queueB 创建 vhostB，这样就隔离开来了。
  - 一个 broker 可以开设多个 vhost，用于不同用户的权限分离.

## 二、发送端确认

### 事务机制

channel.txSelect,channel.txCommit,channel.txRollback 用于将信道设置为事务模式，

```java
channel.txSelect();
channel.basicPublish(EXCHANGE  NAME , ROUTING  KEY ,MessageProperties . PERSISTENTTEXT_PLAIN ,"transaction  messages".getBytes());
channel.txCommit();
```

- 事务模式的四个步骤：
  - 1.tx.select，将信道置为事务模式
  - 2.broker 回复 tx.select-ok,确认已经将信道置为事务模式
  - 3.在消息发送完成后，broker 发送 tx.commit 提交事务
  - 4.broker 回复 tx.commit-ok，确认事务提交
- 缺点：事务机制在发送一条消息之后会使发送端阻塞，会降低 mq 的吞吐量

### 发送方确认（comfirm 模式）

生产者将信道置为 confirm 模式后，所有在该信道上的消息后对被指派一个确认的 Id,一旦消息被投递到匹配的队列之后，rabbitmq 就会异步发送一个确认给生产者（包含消息的唯一 Id）,这就使得生产者知晓消息已经达到目的地了。如果消息和队列设置了持久化，确认消息会在写入磁盘后发出。

> 下面代码为在 springboot 中的用法

```java
@Component
public class MsgDirectSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;


    public boolean send(String msg, String orderNo) {
        rabbitTemplate.setExchange(ExchangeConstant.DIRECT_EXCHANGE_A);
        rabbitTemplate.setRoutingKey(RouteKeyConstant.ROUTEKEY_A);
        rabbitTemplate.setConfirmCallback((correlationData, ack, s) -> {
            String sourceOrderNo = correlationData.getId();
            if (ack) {
                System.out.println("订单:"+sourceOrderNo+"推送成功");
            } else {
                System.out.println("订单:"+sourceOrderNo+"推送失败");
            }
        });
        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -> {
            System.out.println("================");
            System.out.println("message = " + message);
            System.out.println("replyCode = " + replyCode);
            System.out.println("replyText = " + replyText);
            System.out.println("exchange = " + exchange);
            System.out.println("routingKey = " + routingKey);
            System.out.println("================");
        });
        CorrelationData correlationData=new CorrelationData(orderNo);
        rabbitTemplate.correlationConvertAndSend(msg, correlationData);
        return true;
    }
}
```

- comfirmCallBack:始终会回调，根据 ack 参数判断是否成功到达 exchange。
- returnCallBack:表示如果你的消息已经正确到达交换机，但是没有到达 queue，那么就会回调 returnCallBack，并且把信息送回给你。（必须 rabbitTemplate.setMandatory(true)，不然当发送到交换器成功，但是没有匹配的队列，不会触发 ReturnCallback 回调。而且 ReturnCallback 比 ConfirmCallback 先回调）。
- 不能单单依靠 ConfirmCallback 的 ack 返回值为 true，就断定当前消息发送成功了,有可能并没有到达队列，却这种情况下，会先回调 returnCallBack，然后 confirmcallBack 的 ack 为 true.

## 三、消费端确认（ACK）

消费者在订阅队列时，可以指定 autoAck 参数

- 自动确认（autoAck=true）：rabbitmq 会自动把发送出去的消息置为确认，然后从内存(或磁盘)中删除，而不管消费者是否真正地消费到了这些消息。
- 手动确认（autoAck=false）:此时队列中会从在两种消息，一部分是等待投递给消费者的消息，一部分是已经投递给消费者，但是没有收到消费者确认信号的消息。如果 rabbitmq 一直没有收到消费者确认，且消费者已经断开,则消息会重新入队。
  > 下面代码为在 springboot 中的用法

```java
 @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = QueueConstant.QUEUE_E, durable = "true"),
            exchange = @Exchange(value = ExchangeConstant.FANOUT_EXCHANGE_A)))
    public void receiveFanout(Message message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws Exception {
        try {
            String msg = new String(message.getBody());
            System.out.println("收到消息：" + msg);

            //执行业务逻辑

            //返回ack
            channel.basicAck(tag, false);
        } catch (Exception e) {
            // true: 如果被拒绝的消息应该重新排队，否则为false
            channel.basicReject(tag, true);
        }
    }
```

- basicReject(long deliveryTag, boolean requeue)：deliveryTag：可以看做消息的编号。requeue=true 用于表示消息将重新入队，requeue=false 表示消息将被从队列中移除。
- basicAck(long deliveryTag, boolean multiple) :multiple=false:表示单条模式,multiple=false:表示多条模式，即确认 deliveryTag 编号之前的所有未被确认的消息。
- basicNack(long deliveryTag, boolean multiple, boolean requeue) ：multiple=false 时和 basicReject 相同的作用。
- Basic.RecoverOk basicRecover(boolean requeue):TODO

## 四、死信队列

#### what

- 死信：消息被拒绝（basic.reject/basic.Nack），且 requeue=false 即不在重新入队；消息过期；队列达到最大长度

#### why

死信队列实际上就是，当我们的业务队列处理失败(比如抛异常并且达到了 retry 的上限)，就会将消息重新投递到另一个 Exchange(Dead Letter Exchanges)，该 Exchange 再根据 routingKey 重定向到另一个队列，在这个队列重新处理该消息

## 五、延迟队列

## 六、优先级队列

#### 参考文章

[Introducing Publisher Confirms](https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/)
