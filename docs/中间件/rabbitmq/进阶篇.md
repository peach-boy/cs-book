# 进阶篇

##### 1.发送端确认

###### 事务机制
channel.txSelect,channel.txCommit,channel.txRollback用于将信道设置为事务模式，
```
channel.txSelect();
channel.basicPublish(EXCHANGE  NAME , ROUTING  KEY ,MessageProperties . PERSISTENTTEXT_PLAIN ,"transaction  messages".getBytes());
channel.txCommit();
```
* 事务模式的四个步骤：
    * 1.tx.select，将信道置为事务模式
    * 2.broker回复tx.select-ok,确认已经将信道置为事务模式
    * 3.在消息发送完成后，broker发送tx.commit提交事务
    * 4.broker回复tx.commit-ok，确认事务提交 
* 缺点：事务机制在发送一条消息之后会使发送端阻塞，会降低mq的吞吐量

##### 发送方确认（comfirm模式）
生产者将信道置为confirm模式后，所有在该信道上的消息后对被指派一个确认的Id,一旦消息被投递到匹配的队列之后，rabbitmq就会异步发送一个确认给生产者（包含消息的唯一Id）,这就使得生产者知晓消息已经达到目的地了。如果消息和队列设置了持久化，确认消息会在写入磁盘后发出。
```
try {
			channel.confirmSelect();//将信道设置为confirm模式
			channel.basicPublish("exchange_name","routingKey",null,"msg".getBytes());
			if(!channel.waitForConfirms()){
				System.out.println("send msg failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
```
confirm模式是每一条消息后就调用channel.waitForConfims方法，之后等待broker确认，这其实是一种串行同步等待的方式。和事务模式差不多。改进方法：
* 批量confirm方法
* 异步confirm方法



#### 2.发送端确认（ACK）
消费者在订阅队列时，可以指定autoAck参数
* 自动确认（autoAck=true）：rabbitmq会自动把发送出去的消息置为确认，然后从内存(或磁盘)中删除，而不管消费者是否真正地消费到了这些消息。
* 手动确认（autoAck=false）:此时队列中会从在两种消息，一部分是等待投递给消费者的消息，一部分是已经投递给消费者，但是没有收到消费者确认信号的消息。如果rabbitmq一直没有收到消费者确认，且消费者已经断开,则消息会重新入队。


#### 死信队列

#### 延迟队列

#### 优先级队列

#### 
