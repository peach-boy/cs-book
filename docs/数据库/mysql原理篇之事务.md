# mysql 原理篇之事务

### 一、基本概念

- 原子性：作为一个不可分割的最小单位，整个事务要么全部执行，要么全部失败回滚。
- 一致性：从一个一致性状态转换到另一个一致性的状态。
- 隔离性:一个事务的影响在该事务提交前，对其他事务都不可见(通过锁实现)。
- 持久性：事务一旦提交，其结果就是永久性的。即使发生宕机，数据库也能将数据恢复。

### 二、INNODB 事务原理

### 1. update 的执行过程

![](../../pic/mysql/mysql事务_1.webp)

> 1.  执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
> 2.  执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
> 3.  引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
> 4.  执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
> 5.  执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

### 三、隔离级别

引入隔离级别是为了解决以下问题

- 脏读：一个事务读取到了，另一个事务修改了，但未提交的数据。
- 不可重复读：对同一个行数据的两次读取，期间另一个事务对该行数据做了修改，导致两次读取数据不一致的问题称为不可重复读
- 幻读：当某个事务在读取某个范围的记录时，另一个事务又在该范围内插入或删除了记录，当之前的事务再次读取该范围内的记录时，会产生幻读。具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。主要侧重于 insert 和 delete 时

几种隔离级别

- read uncommited(读未提交)：即使事务未提交，对其他事务也是可见的，事务可以读取未提交的事务。
- read commited(读提交)：即事务未提交，对其他事务不可见。
- repeatable read(可重复读):该级别保证了在同一个事务中多次读取同样的记录的结果时一致的。为 innoDB 的默认隔离级别
- serializable(串行化)：最高的隔离级别。会在每读取一行数据上都加锁，所以可能导致大量的超时和锁争用问题。
  > 隔离级别：高->低：serializable->repeatable read->read commited->read uncommited
  > 隔离级别越低，事务请求的锁越少，或者保持锁的时间越短。这也是为什么大多数数据库系统的默认事务隔离级别时 read uncommited.

| 隔离级别     | 脏读可能性 | 不可重复读可能性 | 幻读可能性                 |
| ------------ | ---------- | ---------------- | -------------------------- |
| RU           | 是         | 是               | 是                         |
| RC           | 否         | 是               | 是                         |
| RR           | 否         | 否               | 否(innoDB 为否，mvcc 实现) |
| serializable | 否         | 否               | 否                         |

> 即 InnoDB 在 repeatable read 级别下已经实现了和 serializable 等同的效果
