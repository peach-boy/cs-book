# mysql 原理篇之事务

### 一、基本概念

- 原子性：作为一个不可分割的最小单位，整个事务要么全部执行，要么全部失败回滚。
- 一致性：从一个一致性状态转换到另一个一致性的状态。
- 隔离性:一个事务的影响在该事务提交前，对其他事务都不可见(通过锁实现)。
- 持久性：事务一旦提交，其结果就是永久性的。即使发生宕机，数据库也能将数据恢复。

### 二、INNODB 事务原理

### 1. 事务日志

在 innoDB 引擎中，事务日志通过 redolog 和日志缓冲(innodb log buffer)来实现。

1. 当开始一个事务时，会记录该事务个一个 lSN(log sequence number 日志序列号)
2. 当事务执行时，会往日志缓冲里插入事务日志。
3. 当事务提交时，会将日志缓冲中的事务日志写入磁盘。也就是在改数据之前，先记录日志。称为预写日志方式（write-ahead logginh）WAL

### 三、隔离级别

引入隔离级别是为了解决以下问题

- 脏读：一个事务读取到了，另一个事务修改了，但未提交的数据。
- 不可重复读：对同一个行数据的两次读取，期间另一个事务对该行数据做了修改，导致两次读取数据不一致的问题称为不可重复读
- 幻读：当某个事务在读取某个范围的记录时，另一个事务又在该范围内插入或删除了记录，当之前的事务再次读取该范围内的记录时，会产生幻读。具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。主要侧重于 insert 和 delete 时

几种隔离级别

- read uncommited(读未提交)：即使事务未提交，对其他事务也是可见的，事务可以读取未提交的事务。
- read commited(读提交)：即事务未提交，对其他事务不可见。
- repeatable read(可重复读):该级别保证了在同一个事务中多次读取同样的记录的结果时一致的。为 innoDB 的默认隔离级别
- serializable(串行化)：最高的隔离级别。会在每读取一行数据上都加锁，所以可能导致大量的超时和锁争用问题。
  > 隔离级别：高->低：serializable->repeatable read->read commited->read uncommited
  > 隔离级别越低，事务请求的锁越少，或者保持锁的时间越短。这也是为什么大多数数据库系统的默认事务隔离级别时 read uncommited.

| 隔离级别     | 脏读可能性 | 不可重复读可能性 | 幻读可能性                 |
| ------------ | ---------- | ---------------- | -------------------------- |
| RU           | 是         | 是               | 是                         |
| RC           | 否         | 是               | 是                         |
| RR           | 否         | 否               | 否(innoDB 为否，mvcc 实现) |
| serializable | 否         | 否               | 否                         |

> 即 InnoDB 在 repeatable read 级别下已经实现了和 serializable 等同的效果
