# mysql之事务原理（InnoDB）


### 一、基本概念
* 原子性：作为一个不可分割的最小单位，整个事务要么全部执行，要么全部失败回滚。
* 一致性：从一个一致性状态转换到另一个一致性的状态。
* 隔离性:一个事务的影响在该事务提交前，对其他事务都不可见(通过锁实现)。
* 持久性：事务一旦提交，其结果就是永久性的。即使发生宕机，数据库也能将数据恢复。



### 二、事务日志
在innoDB引擎中，事务日志通过redolog和日志缓冲(innodb log buffer)来实现。
1. 当开始一个事务时，会记录该事务个一个lSN(log sequence number日志序列号)
2. 当事务执行时，会往日志缓冲里插入事务日志。
3. 当事务提交时，会将日志缓冲中的事务日志写入磁盘。也就是在改数据之前，先记录日志。称为预写日志方式（write-ahead logginh）WAL





### 三、隔离级别

引入隔离级别是为了解决以下问题
* 脏读：一个事务读取到了，另一个事务修改了，但未提交的数据。
* 不可重复读：对同一个行数据的两次读取，期间另一个事务对该行数据做了修改，导致两次读取数据不一致的问题称为不可重复读
* 幻读：当某个事务在读取某个范围的记录时，另一个事务又在该范围内插入或删除了记录，当之前的事务再次读取该范围内的记录时，会产生幻读。具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。主要侧重于insert和delete时

几种隔离级别
* read uncommited(读未提交)：即使事务未提交，对其他事务也是可见的，事务可以读取未提交的事务。
* read commited(读提交)：即事务未提交，对其他事务不可见。
* repeatable read(可重复读):该级别保证了在同一个事务中多次读取同样的记录的结果时一致的。为innoDB的默认隔离级别
* serializable(串行化)：最高的隔离级别。会在每读取一行数据上都加锁，所以可能导致大量的超时和锁争用问题。
>隔离级别高->低：serializable->repeatable read->read commited->read uncommited
>隔离级别越低，事务请求的锁越少，或者保持锁的时间越短。这也是为什么大多数数据库系统的默认事务隔离级别时read uncommited.

|隔离级别|脏读可能性|不可重复读可能性|幻读可能性|
|-|-|-|-|-|
|RU	| 是|是|是|
|RC | 否|是|是|
|RR | 否|否| 否(innoDB为否，mvcc实现)|
|serializable|否|否|否|
>即InnoDB在repeatable read级别下已经实现了和serializable等同的效果


### 四、MVCC
MVCC的意思用简单的话讲就是对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。

#### 1.实现原理
InnoDB下的MVCC时通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个存了行的创建时间，一个存了行的过期时间（或删除时间）。当然并不是存储的实际时间，而是系统版本号。每开始一个新事务，系统版本号就会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录做比较。
repeatable read隔离级别的下的实现
* select ：读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号
* insert: 保存当前事务版本号为行的创建版本号
* delete：保存当前事务版本号为行的删除版本号
* update: 插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行

>MVCC只在repetable read和read commited这两个隔离级别下工作，其他隔离级别都和MVCC不兼容。因为read uncommited总是读取行最新的数据行，而不是符合当前事务版本的数据行，而serializable则会为所有读取的行都加锁。

#### 2.举个例子
1. 一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了
2. 另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。
3. 第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了
4. 事务B又一次读取了X。这时
* 如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2
* 如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。
>注意，这里B不论是Read Committed，还是Repeatable Read，都不会被锁，都能立刻拿到结果。这也就是MVCC存在的意义。

#### 3.快照读和当前读
* 快照读：读取历史数据的方式，我们叫它快照读 (snapshot read)
* 当前读：读取数据库当前版本数据的方式