# mysql 原理篇之 MVCC

## 一、什么是 MVCC

MVCC 的意思用简单的话讲就是对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。

## 二、如何实现

### 1.原理

InnoDB 下的 MVCC 时通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个存了行的创建时间，一个存了行的过期时间（或删除时间）。当然并不是存储的实际时间，而是系统版本号。每开始一个新事务，系统版本号就会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录做比较。
repeatable read 隔离级别的下的实现

- select ：读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号
- insert: 保存当前事务版本号为行的创建版本号
- delete：保存当前事务版本号为行的删除版本号
- update: 插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行

> MVCC 只在 repetable read 和 read commited 这两个隔离级别下工作，其他隔离级别都和 MVCC 不兼容。因为 read uncommited 总是读取行最新的数据行，而不是符合当前事务版本的数据行，而 serializable 则会为所有读取的行都加锁。

### 2.举个例子

1. 一个事务 A（txnId=100）修改了数据 X，使得 X=1，并且 commit 了
2. 另外一个事务 B（txnId=101）开始尝试读取 X，但是还 X=1。但 B 没有提交。
3. 第三个事务 C（txnId=102）修改了数据 X，使得 X=2。并且提交了
4. 事务 B 又一次读取了 X。这时

- 如果事务 B 是 Read Committed。那么就读取 X 的最新 commit 的版本，也就是 X=2
- 如果事务 B 是 Repeatable Read。那么读取的就是当前事务（txnId=101）之前 X 的最新版本，也就是 X 被 txnId=100 提交的版本，即 X=1。
  > 注意，这里 B 不论是 Read Committed，还是 Repeatable Read，都不会被锁，都能立刻拿到结果。这也就是 MVCC 存在的意义。

### 三、快照读和当前读

- 快照读：读取历史数据的方式，我们叫它快照读 (snapshot read)
- 当前读：读取数据库当前版本数据的方式
